---
title: "Appendix 2"
author: ''
date: "April 27, 2017"
output:
  word_document: default
geometry: margin=.2in
classoption: landscape
---

The \texttt{greedy} R function, uses the Greedy algorithm to step through a simplified subset of models by deleting "eligible" predictors with minimum $|t|$ values. By eligible predictors we mean that "no main effect can be dropped until all interactions and curvature terms involving that variable have been dropped."


```{r set-options, echo=FALSE, cache=FALSE}
options(width = 150)
```


## The current algorithm:


```{r, echo = T}
# formula = A formula for a linear model.  Must currently be specified using main effects ONLY to allow identification of so-called eligible models.  
# Interactions and quadratic terms will be generated by the function.
# data = An optional data frame that contains non-global variables within formula.
# center = If specified, a character vector containing names of quantitative variables (specified in formula) to be centered. 
# digits = Number of digits in output.
# inform = Type of information-theoretic criterion to be used in model evaluation, one of "AIC", "BIC", or "PRESS" (predicted R^2).

greedy <- function(formula, data = NULL, center = NULL, digits = 5, inform = "AIC"){
 
  require(asbio)
  data <- get_all_vars(formula, data = data)
  if(!is.null(center)){
    w <- which(names(data) == center)
    temp <- apply(data[,w], 2, function(x) x - mean(x))
    data[,w] <- temp
  } 
  m <- model.frame(formula, data = data)
  Y <- model.extract(m, "response")
  terms <- terms(m)
  X <- attr(terms,"term.labels")
  k <- length(X)
      
      d <- attr(terms,"dataClasses")[2:(length(X)+1)]
      Xn <- X[d == "numeric"]; Xnn <- length(Xn[!is.na(Xn)])
      Xc <- X[d == "factor"]; Xcn <- length(Xc[!is.na(Xc)])
  
  steps <- (1 + (k) + (k^2 - k)/2 + Xnn) 
  
    inf <- function(model, inform){ # choose information theoretic criterion
      switch(inform, 
        AIC = AIC(model),
        BIC = BIC(model),
        PRESS = press(model, as.R2 = TRUE))
    }
        
  tab <- matrix(nrow = steps, ncol = 3)
  colnames(tab) <- c("Model", "Drop", inform)
  test <- lm(formula, data = data)
  
    if(steps==1) tab[1,] = c(deparse(formula(test$terms)), " ", round(inf(test, inform), digits = digits)) # intercept only model
    
    else if(steps>=2){
      Xsq <- paste("I(", Xn, "^2)", sep="")
      Xint <- outer(X, X, function(x,y) paste(x,":",y,sep=""))
      Xint <- Xint[upper.tri(Xint)]
      Xall <- c(X, Xint, Xsq)
      
        # -- Categorical variables in lm --#
          if(Xcn >= 1){
           Xcm <- data.frame(data[,names(data)==Xc]); names(Xcm) <- Xc
              nlXcm <- matrix(ncol = 1, nrow = Xcn) 
                for(i in ncol(Xcm)) nlXcm[i] <- nlevels(Xcm[,i])
            
           # Xcmu <- paste(Xc, lXcm[1:nlXcm], sep="")
            Xcm1 <- list()
              for(i in 1:Xcn){
              Xcm1[[i]] <- paste(Xc[i],levels(data[,names(data)==Xc[i]]), sep="")[2:nlXcm[i]]
              }
            names(Xcm1) <- Xc
            
            Xclm <- 1:length(Xcm1) + 1 #  
            
            for(i in 1:Xcn) {
              temp <- cbind(rep(names(Xcm1)[i], length(Xcm1[[i]])), Xcm1[[i]])
              if(Xcn > 1){ Xclm <- rbind(Xclm, temp)}
              if(Xcn == 1) Xclm <- temp
              Xclm
          }
      
            if(nrow(Xclm)>1) Xclm <- Xclm[-1,]
      
            Xsqlm <- cbind(as.matrix(Xsq), as.matrix(Xsq))
            Xdrop <- X[-(Xclm[,1] == X)]
            XnewL <- c(Xclm[,2], Xdrop)
            XnewF <- c(Xclm[,1], Xdrop)
            
            XintL <- outer(XnewL, XnewL, function(x,y) paste(x,":",y,sep=""))
            XintL <- XintL[upper.tri(XintL)]
            XintF <- outer(XnewF, XnewF, function(x,y) paste(x,":",y,sep=""))
            XintF <- XintF[upper.tri(XintF)]
            
            Xlm <- rbind(cbind(as.matrix(Xn), as.matrix(Xn)), Xclm, Xsqlm, cbind(as.matrix(XintF), as.matrix(XintL)))   
            colnames(Xlm) <- c("Predictor", "in_lm")
          }
      
      #-------------------------------#
      
      Yname <- names(m)[1]
      
      f <- as.formula(paste(c(paste(Yname,"~ 1 "), Xall), collapse = " + "))
      sat <- lm(f, data = data)
        redo <- function(drop1, sumsat){
        sumsat1 <- sumsat[rownames(sumsat)!=drop1,]
        if(class(sumsat1)=="numeric") sumsat1 = t(as.matrix(sumsat1))
        rn <- rownames(sumsat)[rownames(sumsat)!=drop1]
        if(nrow(sumsat1)==1) rownames(sumsat1) = rn
        drop2 <- rn[which(abs(sumsat1[,3]) == min(abs(sumsat1[,3])))]
        sumsat2 = sumsat[rownames(sumsat)!=drop2,]
        res <- list(sumsat = sumsat2, drop1 = drop2)
        res
      }
      
      drops <-function(mod1, X, data){
        np <- nrow(coef(summary(mod1)))
        if(np == 2){
          new.mod <- update(mod1, ~ 1)
          res <- list(formula = paste(Yname,"~ 1"), model = new.mod, drop = attr(terms(mod1), "term.labels"), 
                      inf.crit = round(inf(new.mod, inform), digits = digits))
        }
        if(np > 2){
          sumsat <- coef(summary(mod1))[2:np,]
          drop1 <- rownames(sumsat)[which(abs(sumsat[,3]) == min(abs(sumsat[,3])))]
          if(Xcn >= 1){drop1 <- Xlm[,1][Xlm[,2]==drop1]
          m <- match(rownames(sumsat),Xlm[,2]); rownames(sumsat) <- Xlm[,1][m]}
          mod.terms <- attr(terms(mod1), "term.labels")
        
          #--- find a legitimate model for dropping (there is a better way of doing this)" ----#
            
          if(any(X==drop1) & length(grep(drop1, mod.terms[mod.terms!=drop1]))>0){
            drop1 <- redo(drop1, sumsat)$drop1
            if(any(X==drop1) & length(grep(drop1, mod.terms[mod.terms!=drop1])>0)){
              drop1 <- redo(drop1, sumsat)$drop1
              if(any(X==drop1) & length(grep(drop1, mod.terms[mod.terms!=drop1])>0)){
                drop1 <- redo(drop1, sumsat)$drop1 
                if(any(X==drop1) & length(grep(drop1, mod.terms[mod.terms!=drop1])>0)){
                  stop("Flawed model") 
                   }
                }
            }
          }
          f1 <- as.formula(paste(c(paste(Yname,"~ 1 "), mod.terms[mod.terms!=drop1]), collapse=" + "))
          new.mod <- lm(f1, data= data)
          res <- list(formula = paste(c(paste(Yname,"~ 1 "), mod.terms[mod.terms!=drop1]), collapse=" + "), 
                      model = new.mod, drop = drop1, inf.crit = round(inf(new.mod, inform), digits = digits))
        }
        res
      }
      
      j = 2; temp <- sat
      tab[1,] <-c(paste(c(paste(Yname,"~ 1"), Xall), collapse=" + "), " ", round(inf(temp, inform), digits = digits))
     
       while(j <= steps){
        temp <- drops(temp, X, data = data)
        tab[j,] <- c(temp$formula, temp$drop, temp$inf.crit) 
        temp <- temp$model
        j = j + 1
      }
    }
    if(inform == "AIC" | inform == "BIC") opt <- which(as.numeric(tab[,3])== min(as.numeric(tab[,3])))
    if(inform == "PRESS") opt <- which(as.numeric(tab[,3]) == max(as.numeric(tab[,3])))
      best <- tab[opt,][1]
      best <- lm(noquote(best), data = data)
  res <- list()
    res$out <- data.frame(tab)
    res$method <- inform
    res$best <- best
    res$data <- data
    class(res) <- "greedy"
  res
}

print.greedy <- function (x, ...){ 
    cat("\n")
    out <- structure(x$out)
    print(out)
    invisible(x)
}


```

## Example: Case 0902
### Data from Case 0902, ``The Statistical Slueth'' Ramsey and Schaefer (1997)


```{r, comment = NA}
library(MASS)
library(asbio)
#data(case0902) 
readFile <- "Datasets/case0902.csv"
case0902 <- read.csv(file = readFile, header = FALSE, skip = 1) 
g0902 <- greedy(log(Y) ~ log(Xb) + Xg + Xl, data = case0902)
g0902

g0902$best

s0902<- stepAIC(lm(log(Y) ~ I(log(Xb)^2) + I(Xg^2) + I(Xl^2) + (log(Xb) + Xg + Xl)^2, data = case0902), trace = FALSE)
s0902

# center Xs to reduce collinearity

library(car)
vif(g0902$best)
g0902c <- greedy(log(Y) ~ log(Xb) + Xg + Xl, data = case0902, center = c("Xg","Xl")) 
vif(g0902c$best)
```
  

## Case 1202 
### Data from Case 1202, ``The Statistical Slueth'' Ramsey and Schaefer (1997)

```{r, comment = NA, tidy = TRUE}
data(case1202) 
g1202 <- greedy(Yhire ~ Xsex + Xed + Xexp, data = case1202)
g1202
g1202$best
vif(g1202$best)
stepAIC(lm(Yhire ~  I(Xed^2) + I(Xexp^2) + (Xed + Xexp + Xsex)^2, data = case1202), trace = FALSE)
```
